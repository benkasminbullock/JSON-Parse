[% github="https://github.com/benkasminbullock/JSON-Parse/blob" %]
[% MACRO repo(file) BLOCK -%]
L<F<[% file %]>|[% info.repo %]/[% commit.commit %]/[% file %]>
[%- END %]
[% MACRO example(file) BLOCK %]
[%- pl = file _ ".pl" -%]
[%- out = file _ "-out.txt" -%]
[% INCLUDE $pl | xtidy %]

produces output

[% INCLUDE $out | xtidy %]

(This example is included as L<F<[% pl %]>|https://fastapi.metacpan.org/source/BKB/JSON-Parse-[% version %]/examples/[% pl %]> in the distribution.)
[% END %]
[%- MACRO since(what,version) BLOCK -%]
🎲 This [% what %] was added in version [% version %].
[%- END -%]

=pod

=encoding UTF-8

=head1 NAME

JSON::Parse - Parse JSON

=head1 SYNOPSIS

[% INCLUDE "synopsis.pl" | xtidy %]

Convert JSON into Perl.

[% version_text %]

=head1 DESCRIPTION

A module for parsing JSON. (JSON means "JavaScript Object Notation"
and it is specified in L</RFC 8259>.)

JSON::Parse offers the function L</parse_json>, which takes a string
containing JSON, and returns an equivalent Perl structure. It also
offers validation of JSON via L</valid_json>, which returns true or
false depending on whether the JSON is correct or not, and
L</assert_valid_json>, which produces a descriptive fatal error if the
JSON is invalid. A function L</read_json> reads JSON from a
file, and there is a safer version of L</parse_json> called
L</parse_json_safe> which doesn't throw exceptions.

For special cases of parsing, there are also methods L</new> and
L</run>, which create a JSON parsing object and run it on text. See
L</METHODS>.

JSON::Parse accepts only UTF-8 as input. See L</UTF-8 only> and
L</Handling of Unicode>.

=head1 FUNCTIONS

=head2 assert_valid_json

[% example("assert") %]

This is the underlying function for L</valid_json>. It runs at the
same speed, but it throws an error if the JSON is wrong, rather than
returning 1 or 0. See L</DIAGNOSTICS> for the error format, which is
identical to L</parse_json>.

This cannot detect key collisions in the JSON since it does not store
values. See L</Key collisions> for more on this module's handling of
non-unique names in the JSON.

The behaviour of disallowing empty inputs was changed in version
0.49.

=head2 parse_json

    use JSON::Parse 'parse_json';
    my $perl = parse_json ('{"x":1, "y":2}');

This function converts JSON into a Perl structure, either an array
reference, a hash reference, or a scalar.

If the first argument does not contain a complete valid JSON text, is
the undefined value, an empty string, or a string containing only
whitespace C<parse_json> throws a fatal error ("dies").

If the argument contains valid JSON, the return value is either a hash
reference, an array reference, or a scalar. If the input JSON text is
a serialized object, a hash reference is returned:

[% example("hash") %]

If the input JSON text is a serialized array, an array reference is
returned:

[% example("array") %]

Otherwise a Perl scalar is returned. 

The behaviour of allowing a scalar was added in version 0.32 of this
module. This brings it into line with the new specification for
JSON. The behaviour of disallowing empty inputs was changed in version
0.49.

The function L</parse_json_safe> offers a version of this function
with various safety features enabled.

=head2 parse_json_safe

This is almost the same thing as L</parse_json>, but has the following
differences:

=over

=item Does not throw exceptions

If the JSON is invalid, a warning is printed and the undefined value
is returned, as if calling L</parse_json> like this:

    eval {
        $out = parse_json ($json);
    };
    if ($@) {
        carp $@;
	$out = undef;
    }

=item Detects key collisions

This switches on L</detect_collisions>, so that if the JSON contains
non-unique names, a warning is printed and the undefined value is
returned. See L</Key collisions> for an explanation of what a key
collision is.

=item Booleans are not read-only

This switches on L</copy_literals> so that JSON true, false and null
values are copied. These values can be modified, but they will not be
converted back into C<true> and C<false> by L<JSON::Create>.

=item Errors are reported by carp

Parsing errors are reported by L<Carp/carp>, so the error line number
refers to the caller's line.

=back

As the name implies, this is meant to be a "safety-first" version of
L</parse_json>. 

[% since('function', '0.38') %]

=head2 read_json

    use JSON::Parse 'read_json';
    my $p = read_json ('filename');

This is exactly the same as L</parse_json> except that it reads the
JSON from the specified file rather than a scalar. The file must be in
the UTF-8 encoding, and is opened as a character file using
C<:encoding(UTF-8)> (see L<PerlIO::encoding> and L<perluniintro> for
details). The output is marked as character strings.

This is a convenience function written in Perl. You may prefer to read
the file yourself using another module if you need faster performance.

This was renamed from L</json_file_to_perl> in version 0.59. The old
name will also continue to work indefinitely.

=head2 valid_json

    use JSON::Parse 'valid_json';
    if (valid_json ($json)) {
        # do something
    }

C<valid_json> returns I<1> if its argument is valid JSON and I<0> if
not. It runs several times faster than L</parse_json>. This gain in
speed is obtained because it discards the input data after reading it,
rather than storing it into Perl variables.

This does not supply the actual errors which caused invalidity. Use
L</assert_valid_json> to get error messages when the JSON is invalid.

This cannot detect key collisions in the JSON since it does not store
values. See L</Key collisions> for more on this module's handling of
non-unique names in the JSON.

=head1 METHODS

If you need to parse JSON and you are not satisfied with the parsing
options offered by L</parse_json> and L</parse_json_safe>, you can
create a JSON parsing object with L</new> and set various options on
the object, then use it with L</run>. These options include the
ability to copy JSON literals with L</copy_literals>, switch off fatal
errors with L</warn_only>, detect key collisions in objects with
L</detect_collisions>, and set the JSON literals to user defined
values with the methods described under L</Methods for manipulating
literals>.

These methods only work on an object created with L</new>; they do not
affect the behaviour of L</parse_json> or L</parse_json_safe>.

=head2 check

    eval {
        $jp->check ($json);
    };

This does the same thing as L</assert_valid_json>, except its
behaviour can be modified using the L</diagnostics_hash> method.

[% since('method', '0.48') %] This is for the benefit of
L<JSON::Repair>.

=head2 copy_literals

    $jp->copy_literals (1);

With a true value, copy JSON literal values (C<null>, C<true>, and
C<false>) into new Perl scalar values, and don't put read-only values
into the output. 

With a false value, use read-only scalars:

    $jp->copy_literals (0);

The C<copy_literals (1)> behaviour is the behaviour of
L</parse_json_safe>. The C<copy_literals (0)> behaviour is the
behaviour of L</parse_json>.

If the user also sets user-defined literals with L</set_true>,
L</set_false> and L</set_null>, that takes precedence over this.

[% since('method', '0.38') %]

=head2 detect_collisions

    $jp->detect_collisions (1);

This switches on a check for hash key collisions (non-unique names in
JSON objects). If a collision is found, an error message L</Name is
not unique> is printed, which also gives the non-unique name and the
byte position where the start of the colliding string was found:

[% example("collide") %]

The C<detect_collisions (1)> behaviour is the behaviour of
L</parse_json_safe>. The C<detect_collisions (0)> behaviour is the
behaviour of L</parse_json>.

[% since('method', '0.38') %]

=head2 diagnostics_hash

    $jp->diagnostics_hash (1);

This changes diagnostics produced by errors from a simple string into
a hash reference containing various fields. This is experimental and
subject to change. This is incompatible with L</warn_only>.

This replaces the previous experimental global variable
C<$json_diagnostics>, which was removed from the module. The hash keys
and values are identical to those provided in the object returned by
C<$json_diagnostics>, with the addition of a key C<error as string>
which returns the usual error.

This requires Perl version 5.14 or later.

[% since('method', '0.46') %]

=head2 get_max_depth

   my $max_depth = $jp->get_max_depth ();

This returns the maximum nesting depth of objects or arrays in the
input JSON. The default value is 10,000.

[% since('method', '0.58') %]

=head2 new

    my $jp = JSON::Parse->new ();

Create a new JSON::Parse object.

[% since('method', '0.38') %]

=head2 run

    my $out = $jp->run ($json);

This does the same thing as L</parse_json>, except its behaviour can
be modified using the methods below.

[% since('method', '0.38') %]

=head2 set_max_depth

    $jp->set_max_depth (42);

Set the maximum nesting depth of objects or arrays in the input
JSON. The default value is 10,000.

[% since('method', '0.58') %]

=head2 warn_only

    $jp->warn_only (1);

Warn, don't die, on error. Failed parsing returns the undefined value,
C<undef>, and prints a warning.

This can be switched off again using any false value:

    $jp->warn_only ('');

[% since('method', 0.41) %]

=head2 Methods for manipulating literals

These methods alter what is written into the Perl structure when the
parser sees a literal value, C<true>, C<false> or C<null> in the input
JSON.

This number of methods is needed because of the possibility that a
user wants to set the output for C<false> to be C<undef>:

    $jp->set_false (undef);

Thus, we cannot use a single function C<< $jp->false (undef) >> to
cover both setting and deleting of values.

[% since('facility', '0.38') %]

[% BLOCK set_literal %]

=head3 set_[% literal %]

    $jp->set_[% literal %] (
[%- IF literal == 'true' -%]
"Yes, that is so true"
[%- ELSIF literal == 'false' -%]
JSON::PP::Boolean::false
[%- ELSIF literal == 'null' -%]
0
[%- END -%]
);

Supply a scalar to be used in place of the JSON C<[% literal %]> literal. 
[% IF literal == 'true' -%]

This example puts the string "Yes, that is so true" into the hash or
array when we hit a "true" literal, rather than the default read-only
scalar:

[% INCLUDE "true-subs.pl" | xtidy %]

prints

[% INCLUDE "true-subs-out.txt" | xtidy %]

[%- ELSIF literal == 'false' %]
In the above example, when we hit a "false" literal, we put
C<JSON::PP::Boolean::false> in the output, similar to L<JSON::PP> and
other CPAN modules like L<Mojo::JSON> or L<JSON::XS>.
[% END %]

To override the previous value, call it again with a new value. To
delete the value and revert to the default behaviour, use
L</delete_[% literal %]>.

[% IF literal == 'true' || literal == 'false' -%]
[%- opposite = 'false' -%]
[%- IF literal == 'false' -%]
[%- opposite = 'true' -%]
[%- END %]

If you give this a value which is not "[% literal %]", as in Perl will
evaluate it as a false in an if statement, it prints a warning
L</User-defined value for JSON [% literal %] evaluates as [% opposite %]>.
You can switch this warning off with L</no_warn_literals>.

[% END %]

[% since('method', '0.38') %]

=head3 delete_[% literal %]

    $jp->delete_[% literal %] ();

Delete the user-defined [% literal %] value. See L</set_[% literal %]>. 

This method is "safe" in that it has absolutely no effect if no
user-defined value is in place. It does not return a value.

[% since('method', '0.38') %]

[% END %]

[% PROCESS set_literal literal = 'true' %]
[% PROCESS set_literal literal = 'false' %]
[% PROCESS set_literal literal = 'null' %]

=head3 no_warn_literals

    $jp->no_warn_literals (1);

Use a true value to switch off warnings about setting boolean values
to contradictory things. For example if you want to set the JSON
C<false> literal to turn into the string "false",

    $jp->no_warn_literals (1);
    $jp->set_false ("false");

See also L</Contradictory values for "true" and "false">.

This also switches off the warning L</User-defined value overrules
copy_literals>.

[% since('method', '0.38') %]

=head1 OLD INTERFACE

The following alternative function names are accepted. These are the
names used for the functions in old versions of this module. These
names are not deprecated and will never be removed from the module.

The names ending in "_to_perl" seem quite silly in retrospect since
surely it is obvious that one is programming in Perl.

=head2 json_to_perl

This is exactly the same function as L</parse_json>.

=head2 json_file_to_perl

This is exactly the same function as L</read_json>. The function was
renamed in version 0.59, after the same function in
L</File::JSON::Slurper>.

=head2 validate_json

This is exactly the same function as L</assert_valid_json>.

=head1 Mapping from JSON to Perl

JSON elements are mapped to Perl as follows:

=head2 JSON numbers

JSON numbers become Perl numbers, either integers or double-precision
floating point numbers, or possibly strings containing the number if
parsing of a number by the usual methods fails somehow.

JSON does not allow leading zeros, like I<0123>, or leading plus
signs, like I<+100>, in numbers, so these cause an L</Unexpected
character> error. JSON also does not allow numbers of the form I<1.>,
but it does allow things like I<0e0> or I<1E999999>. As far as
possible these are accepted by JSON::Parse.

=head2 JSON strings

JSON strings become Perl strings. The JSON escape characters such as
C<\t> for the tab character (see section 2.5 of L</RFC 8259>) are
mapped to the equivalent ASCII character.

=head3 Handling of Unicode

Inputs must be in the UTF-8 format. See L</UTF-8 only>.

If the input to L</parse_json> is marked as Unicode characters, the
output strings will be marked as Unicode characters. If the input is
not marked as Unicode characters, the output strings will not be
marked as Unicode characters. Thus, 

[% INCLUDE "sasori.pl" | xtidy %]

but

[% INCLUDE "ebi.pl" | xtidy %]

Escapes of the form \uXXXX (see page three of L</RFC 8259>) are mapped
to ASCII if XXXX is less than 0x80, or to UTF-8 if XXXX is greater
than or equal to 0x80.

Strings containing \uXXXX escapes greater than 0x80 are also upgraded
to character strings, regardless of whether the input is a character
string or a byte string, thus regardless of whether Perl thinks the
input string is Unicode, escapes like \u87f9 are converted into the
equivalent UTF-8 bytes and the particular string in which they occur
is marked as a character string:

[% INCLUDE "kani.pl" | xtidy %]

This is modelled on the behaviour of Perl's C<chr>:

[% INCLUDE "chr.pl" | xtidy %]

However, JSON::Parse also upgrades the remaining part of the string
into a character string, even when it's not marked as a character
string. For example,

[% example("unicode-details") %]

Although in general the above would be an unsafe practice, JSON::Parse
can do things this way because JSON is a text-only, Unicode-only
format. To ensure that invalid inputs are never upgraded, JSON::Parse
checks each input byte to make sure that it forms UTF-8. See also
L</UTF-8 only>. Doing things this way, rather than the way that Perl
does it, was one of the original motivations for writing this
module.

Surrogate pairs in the form C<\uD834\uDD1E> are also handled. If the
second half of the surrogate pair is missing, an L</Unexpected
character> or L</Unexpected end of input> error is thrown. If the
second half of the surrogate pair is present but contains an
impossible value, a L</Not surrogate pair> error is thrown.

=head2 JSON arrays

JSON arrays become Perl array references. The elements of the Perl
array are in the same order as they appear in the JSON.

Thus

    my $p = parse_json ('["monday", "tuesday", "wednesday"]');

has the same result as a Perl declaration of the form

    my $p = [ 'monday', 'tuesday', 'wednesday' ];

=head2 JSON objects

JSON objects become Perl hashes. The members of the JSON object become
key and value pairs in the Perl hash. The string part of each object
member becomes the key of the Perl hash. The value part of each member
is mapped to the value of the Perl hash.

Thus

    my $j = <<EOF;
    {"monday":["blue", "black"],
     "tuesday":["grey", "heart attack"],
     "friday":"Gotta get down on Friday"}
    EOF

    my $p = parse_json ($j);

has the same result as a Perl declaration of the form

    my $p = {
        monday => ['blue', 'black'],
        tuesday => ['grey', 'heart attack'],
        friday => 'Gotta get down on Friday',
    };

=head3 Key collisions

A key collision is something like the following.

[% example("key-collision") %]

Here the key "a" could be either 1 or 2. As seen in the example,
L</parse_json> overwrites the first value with the second
value. L</parse_json_safe> halts and prints a warning. If you use
L</new> you can switch key collision on and off with the
L</detect_collisions> method.

The rationale for L</parse_json> not to give warnings is that Perl
doesn't give information about collisions when storing into hash
values, and checking for collisions for every key will degrade
performance for the sake of an unlikely occurrence. The JSON
specification says "The names within an object SHOULD be unique." (see
L</RFC 8259>, page 5), although it's not a requirement.

For performance, L</valid_json> and L</assert_valid_json> do not store
hash keys, thus they cannot detect this variety of problem.

=head2 Literals

=head3 false

L</parse_json> maps the JSON false literal to a readonly scalar which
evaluates to the empty string, or to zero in a numeric context. (This
behaviour changed from version 0.36 to 0.37. In versions up to 0.36,
the false literal was mapped to a readonly scalar which evaluated to 0
only.) L</parse_json_safe> maps the JSON literal to a similar scalar
without the readonly constraints. If you use a parser created with
L</new>, you can choose either of these behaviours with
L</copy_literals>, or you can tell JSON::Parse to put your own value
in place of falses using the L</set_false> method.

=head3 null

L</parse_json> maps the JSON null literal to a readonly scalar
C<$JSON::Parse::null> which evaluates to C<undef>. L</parse_json_safe>
maps the JSON literal to the undefined value. If you use a parser
created with L</new>, you can choose either of these behaviours with
L</copy_literals>, or you can tell JSON::Parse to put your own value
in place of nulls using the L</set_null> method.

=head3 true

L</parse_json> maps the JSON true literal to a readonly scalar which
evaluates to C<1>. L</parse_json_safe> maps the JSON literal to the
value 1. If you use a parser created with L</new>, you can choose
either of these behaviours with L</copy_literals>, or you can tell
JSON::Parse to put your own value in place of trues using the
L</set_true> method.

=head3 Round trips and compatibility

The Perl versions of literals produced by L</parse_json> will be
converted back to JSON literals if you use
L<JSON::Create/create_json>. However, JSON::Parse's literals are
incompatible with the other CPAN JSON modules. For compatibility with
other CPAN modules, create a JSON::Parse object with L</new>, and set
JSON::Parse's literals with L</set_true>, L</set_false>, and
L</set_null>.

=head3 A round trip with JSON::Tiny

This example demonstrates round-trip compatibility using L<JSON::Tiny>,
version 0.58:

[% example("json-tiny-round-trip-demo") %]

Most of the other CPAN modules use similar methods to L<JSON::Tiny>,
so the above example can easily be adapted. See also
L<JSON::Create/Interoperability> for various examples.

=head3 Modifying the values

L</parse_json> maps all the literals to read-only values. Because of
this, attempting to modifying the boolean values in the hash reference
returned by L</parse_json> will cause "Modification of a read-only
value attempted" errors:

    my $in = '{"hocus":true,"pocus":false,"focus":null}';
    my $p = json_parse ($in);
    $p->{hocus} = 99;
    # "Modification of a read-only value attempted" error occurs

Since the hash values are read-only scalars, 
C<< $p->{hocus} = 99 >> is like this:

    undef = 99;

If you need to modify the returned hash reference, then delete the
value first:

    my $in = '{"hocus":true,"pocus":false,"focus":null}';
    my $p = json_parse ($in);
    delete $p->{pocus};
    $p->{pocus} = 99;
    # OK

Similarly with array references, delete the value before altering:

    my $in = '[true,false,null]';
    my $q = json_parse ($in);
    delete $q->[1];
    $q->[1] = 'magic';

Note that the return values from parsing bare literals are not
read-only scalars, so

    my $true = JSON::Parse::json_parse ('true');
    $true = 99;

produces no error. This is because Perl copies the scalar.

=head1 RESTRICTIONS

This module imposes the following restrictions on its input.

=over

=item JSON only

JSON::Parse is a strict parser. It only accepts input which exactly
meets the criteria of L</RFC 8259>. That means, for example,
JSON::Parse does not accept single quotes (') instead of double quotes
("), or numbers with leading zeros, like 0123. JSON::Parse does not
accept control characters (0x00 - 0x1F) in strings, missing commas
between array or hash elements like C<["a" "b"]>, or trailing commas
like C<["a","b","c",]>. It also does not accept trailing
non-whitespace, like the second "]" in C<["a"]]>. 

You may find L</JSON::Repair> by the same authors as JSON::Parse
useful if you need to process JSON-like text with tolerance for
errors.

=item No incremental parsing

JSON::Parse does not parse incrementally. It only parses fully-formed
JSON strings which include all opening and closing brackets. This is
an inherent part of the design of the module. Incremental parsing in
the style of L<XML::Parser> would require some kind of callback
structure to deal with the elements of the partially digested
structures, but JSON::Parse was never designed to do this; it merely
converts what it sees into a Perl structure. Claims to offer
incremental JSON parsing in other modules' documentation should be
diligently verified.

=item UTF-8 only

JSON::Parse only parses the UTF-8 format. If input is in a different
Unicode encoding than UTF-8, convert the input before handing it to
this module. For example, for the UTF-16 format,

    use Encode 'decode';
    my $input_utf8 = decode ('UTF-16', $input);
    my $perl = parse_json ($input_utf8);

or, for a file, use C<:encoding> (see L<PerlIO::encoding> and
L<perluniintro>):

    open my $input, "<:encoding(UTF-16)", 'some-json-file'; 

JSON::Parse does not try to determine the nature of the octet stream
using BOM markers. A BOM marker in the input consists of bytes C<0xFE>
and C<0xFF>, both of which are invalid as UTF-8, and thus will cause a
fatal error.

This restriction to UTF-8 applies regardless of whether Perl thinks
that the input string is a character string or a byte
string. Non-UTF-8 input will cause an L</Unexpected character> error.

The latest specification for JSON, L</RFC 8259>, specifies it to be a
UTF-8 only format.

JSON::Parse does not accept Unicode non-characters (U+FFFF, UFDDO,
etc.), UTF-8 representing surrogate pair code points, or bytes outside
the range of Unicode code points as UTF-8 bytes.

=back

=head1 DIAGNOSTICS

L</valid_json> does not produce error messages. L</parse_json> and
L</assert_valid_json> die on encountering invalid
input. L</parse_json_safe> uses L<Carp/carp> to pass error messages as
warnings.

Error messages have the line number, and the byte number where
appropriate, of the input which caused the problem. The line number is
formed simply by counting the number of "\n" (linefeed, ASCII 0x0A)
characters in the whitespace part of the JSON.

In L</parse_json> and L</assert_valid_json>, parsing errors are fatal,
so to continue after an error occurs, put the parsing into an C<eval>
block:

    my $p;                       
    eval {                       
        $p = parse_json ($j);  
    };                           
    if ($@) {                    
        # handle error           
    }

The following error messages are produced:

=over

[% FOR error IN errors %]
[% IF error.error != "invalid" %]
=item [% error.error %]

[% error.description %]

[% END %]
[% END # error in errors %]

=item Contradictory values for "true" and "false"

=over

=item User-defined value for JSON false evaluates as true

This happens if you set JSON false to map to a true value:

    $jp->set_false (1);

To switch off this warning, use L</no_warn_literals>.

[% since('warning', '0.38') %]

=item User-defined value for JSON true evaluates as false

This happens if you set JSON true to map to a false value:

    $jp->set_true (undef);

To switch off this warning, use L</no_warn_literals>.

[% since('warning', '0.38') %]

=item User-defined value overrules copy_literals

This warning is given if you set up literals with L</copy_literals>
then you also set up your own true, false, or null values with
L</set_true>, L</set_false>, or L</set_null>.

[% since('warning', '0.38') %]

=back

=back

=head1 PERFORMANCE

On the author's computer, the module's speed of parsing is
approximately the same as L<JSON::XS>, with small variations depending
on the type of input. For validation, L</valid_json> is faster than
any other module known to the author, and up to ten times faster than
JSON::XS.

Some special types of input, such as floating point numbers containing
an exponential part, like "1e09", seem to be about two or three times
faster to parse with this module than with L<JSON::XS>. In
JSON::Parse, parsing of exponentials is done by the system's C<strtod>
function, but JSON::XS contains its own parser for exponentials, so
these results may be system-dependent. 

At the moment the main place JSON::XS wins over JSON::Parse is in
strings containing escape characters, where JSON::XS is about 10%
faster on the module author's computer and compiler. As of version
0.33, despite some progress in improving JSON::Parse, I haven't been
able to fully work out the reason behind the better speed.

There is some benchmarking code in the github repository under the
directory "benchmarks" for those wishing to test these claims. The
script [% repo("benchmarks/bench") %] is an adaptation of the similar
script in the L<JSON::XS> distribution. The script [%
repo("benchmarks/pub-bench.pl") %] runs the benchmarks and prints them
out as POD.

The following benchmark tests used version [%
benchv.item('JSON::Parse') %] of JSON::Parse, version [%
benchv.item('JSON::XS') %] of L</JSON::XS>, and version [%
benchv.item('Cpanel::JSON::XS') %] of L</Cpanel::JSON::XS> on Perl
version [% benchv.perl.original %] compiled with Clang version [%
benchv.cc %] on FreeBSD 12.2. The files in the "benchmarks" directory
of JSON::Parse. F<short.json> and F<long.json> are the benchmarks used
by L</JSON::XS>.

=over

[% INCLUDE "benchmarks/benchmarks-output.txt" %]

=back

=head1 SEE ALSO

=over

=item RFC 8259

JSON is specified in L<RFC 8259 "The JavaScript Object Notation (JSON) Data Interchange Format"|http://www.ietf.org/rfc/rfc8259.txt>.

=item json.org

L<https://json.org> is the website for JSON, authored by Douglas
Crockford.

=back

=head2 Other CPAN modules for parsing and producing JSON

[% star = "⭐" %] 

The [% star %] represents the number of votes this module has received
on metacpan, on a logarithmic scale. Modules which we recommend are
marked with 👍. Deprecated modules and modules which are definitely
buggy (bug reports/pull requests ignored) and abandoned (no releases
for several years) are marked with 👎 and/or 🐛. Modules we can't work
out are marked with 😕.

=over

=item Modules by the same author

=over

=item JSON::Create

👍 L<JSON::Create> is a companion module to JSON::Parse by the same
author.

=item JSON::Repair

L<JSON::Repair> is an example module which demonstrates using
JSON::Parse to apply some kinds of heuristics to repair "relaxed JSON"
or otherwise broken JSON into compliant JSON.

=item JSON::Tokenize

L<JSON::Tokenize> is part of the JSON::Parse distribution, a tokenizer
which reduces a JSON string to tokens. This makes the JSON::Parse
tokenizer available to people who want to write their own JSON
parsers.

=back
[% MACRO cpm(module) BLOCK %]
=item L<[% module %]>
[% IF mod2info.defined(module) %]
[% info = mod2info.$module %]
[
[%- IF info.log_fav > 0 -%]
[% star.repeat(info.log_fav) %] [% END -%]
Author: L<[% info.author %]|https://metacpan.org/author/[% info.author %]>; Date: C<[% info.date %]>; Version: C<[% info.version %]>]
[% END %]
[% END %]

=item Reading and writing JSON

=over

[% cpm('Cpanel::JSON::XS') %]

This is a fork of L<JSON::XS>. Please see the module for details about
the reasons for the fork.

[% cpm('File::JSON::Slurper') %]

Slurp a JSON file into a data structure, and the reverse. It relies on
L</JSON::MaybeXS>.

[% cpm('Glib::JSON') %]

Uses the JSON library from Glib, a library of C functions for the
Linux GNOME desktop project, so it is independent of the other CPAN
modules. Judging from the fairly sparse documentation, it seems to be
a module where you build the JSON on the fly rather than converting a
Perl structure wholesale into JSON.

[% cpm('JSON') %]

This calls on either L<JSON::PP> or L<JSON::XS>.

[% cpm('JSON::DWIW') %]

👎🐛 This module "Does What I Want", where "I" refers to the module's
author. Development seems to have ceased in 2010, there is a long list
of unfixed bugs, and some of the module's features seem to predate
Unicode support in Perl. It is written in XS, and it claims to accept
a wide variety of non-JSON formats such as comments, single-quoted
strings, trailing commas, etc.

[% cpm('JSON::PP') %]

This is part of the Perl core, installed when you install Perl. "PP"
stands for "Pure Perl", which means it is in Perl-only without the XS
(C-based) parsing. This is slower but may be necessary if you cannot
install modules requiring a C compiler.

[% cpm('JSON::Slurper') %]

Convenient file slurping and spurting of data using JSON. Uses
L</JSON::PP> or L</Cpanel::JSON::XS> if available. The basic idea
seems to be that it uses context to return arrays or hashes as
required, and read and write files without extra stages of opening and
closing the file.

[% cpm('JSON::Syck') %]

👎🐛 Takes advantage of a similarity between YAML (yet another markup
language) and JSON to provide a JSON parser/producer using
L<YAML::Syck>. 

We have never tried this module, but it seems to be semi-deprecated
(the ABSTRACT says "consider using JSON::XS instead!")  and L<there
are a lot of bug reports|https://github.com/toddr/YAML-Syck/issues>
about things like failing to process equals signs. However, the
maintainer is fixing some of the bugs and making new releases, so
we're not really sure.

[% cpm('JSON::Tiny') %]

This is a fork of L</Mojo::JSON>.

[% cpm('JSON::XS') %]

This is an all-purpose JSON module in XS, which means it requires a C
compiler to install.

[% cpm('JSON::YAJL') %]

👎🐛 Wraps a C library called yajl. The module has been abandoned
since ten years ago. Bug reports include serious errors, and pull
requests have been ignored.

[% cpm('Mojo::JSON') %]

Part of the L<Mojolicious> standalone web framework, "pure Perl" JSON
reader/writer. As of version 8.70 of Mojolicious, this actually
depends on L</JSON::PP> but will load L</Cpanel::JSON::XS> if it is
available.

=back

=item Combination modules

These modules rely on more than one back-end module to process JSON
for you.

=over

[% cpm('JSON::Any') %]

👎 This now-deprecated module combines L</JSON::DWIW>, L</JSON::XS>
versions one and two, and L</JSON::Syck>.

[% cpm('JSON::MaybeXS') %]

A module which combines L</Cpanel::JSON::XS>, L</JSON::XS>, and
L</JSON::PP>. The original L</JSON> combines L</JSON::XS> and
L</JSON::PP>, but this prioritizes L</Cpanel::JSON::XS> over
L</JSON::XS>.

[% cpm('JSON::XS::VersionOneAndTwo') %]

👎 A "combination module" which supports two different interfaces of
L</JSON::XS>. However, JSON::XS is now onto version 4.

[% cpm('Mojo::JSON::MaybeXS') %]

👎 This pulls in L</JSON::MaybeXS> instead of L</Mojo::JSON> for
L<Mojolicious> users. It seems to have been rendered obsolete by
modern versions of Mojolicious due to changes to make that depend on
L</Cpanel::JSON::XS> if available.

=back


=item Test-related modules

=over

[% cpm('Test2::Tools::JSON') %]

[% cpm('Test::Deep::JSON') %]

Compare JSON with L<Test::Deep>. As of version 0.05, it relies on
L</JSON::MaybeXS>.

[% cpm('Test::JSON') %]

👎 This offers a way to compare two different JSON strings to see if
they refer to the same object. The most recent version, 0.11, was
released in 2009, and it relies on the deprecated L</JSON::Any>, which
makes it essentially abandoned.

[% cpm('Test::JSON::Entails') %]

👎 Test whether one JSON or Perl structure entails/subsumes
another. The most recent version is from 2012, and it relies on
L</JSON::Any>, so it is probably abandoned. Also, oddly but not
uniquely for CPAN modules with the name JSON in the title, it seems to
not actually have that much to do with JSON, which is a data
serialisation format, but actually be testing Perl hashes and arrays.

[% cpm('Test::JSON::More') %]

JSON Test Utility. As of version 0.02, it relies on L</JSON> but it is
able to use L</JSON::XS> instead, and so probably L</Cpanel::JSON::XS>
would be OK too. According to the documentation, it can test JSON for
validity and compare JSON strings with keys in a different order, and
presumably with different whitespace.

=back

=item Type-related modules

These untangle numbers, strings, and booleans into JSON types.

=over

[% cpm('JSON::TypeInference') %]

😕 Virtually undocumented, it's not clear what this does.

[% cpm('JSON::Types') %]

Change the type of a Perl variable so that it comes out as a number, a
string, or a boolean in the output JSON.

[% cpm('JSON::Types::Flexible') %]

The module is barely documented, but from looking at L<the test
file|https://metacpan.org/source/PINE/JSON-Types-Flexible-0.03/t%2Fjson%2Ftypes%2Fflexible%2Fclass.t>,
this seems to enable you to change the output type of a number or a
string so that you can, for example, make the number C<1> come out as
either a number, C<1>, a string C<"1">, or a boolean, C<true>, in the
output JSON.

[% cpm('JSON::Typist') %]

"Replace mushy strings and numbers with rigidly typed replacements"

Since Perl muddles strings and numbers, this enables you to work out
whether your input JSON was C<"123"> (a string) or C<123> (a number).

=back

=item Special-purpose modules

=over

[% cpm('App::JSON::to') %]

Convert JSON data to other formats. It reads your JSON file or input
and converts it into either YAML or Perl native format using
L<Data::Dumper>.

[% cpm('boolean') %]

👍 This module offers C<true> and C<false> literals in Perl, so you just have

    use boolean;
    my $something = true;

This is very useful for dealing with JSON.

[% cpm('Config::JSON') %]

Configuration files in JSON, with hash comments also allowed.

[% cpm('Devel::JSON') %]

For one-liners.

=over

If you use this module from the command-line, the last value of your
one-liner (-e) code will be serialized as JSON data.

=back

[% cpm('Inline::JSON') %]

"Embed JSON data structures directly into your Perl code". Relies on
L</JSON>.

[% cpm('JSON::Builder') %]

Create JSON under memory limitations.

[% cpm('JSON::Color') %]

🌈 This module generates JSON colorized with ANSI escape sequences.

[% cpm('JSON_File') %]

[% cpm('JSON::MultiValueOrdered') %]

C<JSON::MultiValueOrdered> is a special-purpose module for parsing
JSON objects which have key collisions (something like
C<{"a":1,"a":2}>) within objects.

(JSON::Parse's handling of key collisions is discussed in L</Key
collisions> in this document.)

[% cpm('JSON::String') %]

Automatically change a JSON string when a data structure changes using
tied scalars.

=back

=item Patch, path, pointer, and transform modules

=over

[% cpm('JSON::Assert') %]

"Asserts JSONPaths into a JSON data structure for correct
values/matches"

[% cpm('JSON::MergePatch') %]

[% cpm('JSON::Patch') %]

😕 We don't know what this does, or how it relates to JSON. The example
in the synopsis section of the document doesn't show any JSON, it
shows an example of altering nested hashes in Perl.

[% cpm('JSON::Path') %]

Search nested hashref/arrayref structures using JSONPath.

[% cpm('JSON::Pointer') %]

Extract parts of a JSON string.

[% cpm('JSON::T') %]

Transform JSON using JsonT

[% cpm('JSON::Transform') %]

=back

=item JSON extensions

These modules extend JSON with comments and other things.

=over

[% cpm('JSON::Diffable') %]

"A relaxed and easy diffable JSON variant"

[% cpm('JSON::Relaxed') %]

"An extension of JSON that allows for better human-readability".

[% cpm('JSONY') %]

"Relaxed JSON with a little bit of YAML"

=back

=item Web interactions via JSON

=over

[% cpm('JSON::API') %]

Combines L<LWP::UserAgent> and L<JSON> to make a unified module to
communicate with a web server via JSON.

[% cpm('LWP::JSON::Tiny') %]

[% cpm('WWW::JSON') %]

"Make working with JSON Web API's as painless as possible"

=back

=item Extension modules

These modules extend the existing modules with some extra bits.

=over

[% cpm('JSON::XS::Sugar') %]

Provides booleans and number/string forcing for L</JSON::XS>.

[% cpm('Silki::JSON') %]

Switches on formatting and strict utf8 in a L</JSON::XS> object.

=back

=item Demonstration modules

These modules provide a JSON parser as a demonstration of another
technology.

=over

[% cpm('JSON::Decode::Marpa') %]

[% cpm('JSON::Decode::Regexp') %]

🐛🦟🦋🐞 JSON parser as a single Perl Regex, originally by Randal
Schwartz. This may be ingenious, but it's not remotely a useful JSON
parser. For example, looking at the string part, it provides no
Unicode validation, L<no support for Unicode
escapes|https://metacpan.org/release/JSON-Decode-Regexp/source/lib/JSON/Decode/Regexp.pm#L141>
and it L<allows invalid escapes such as
C<\xFF>|https://metacpan.org/release/JSON-Decode-Regexp/source/lib/JSON/Decode/Regexp.pm#L137>.

[% cpm('MarpaX::Demo::JSONParser') %]

[% cpm('Pegex::JSON') %]

🐛 Based on L<Pegex>.  See
L<our bug report|https://github.com/pegex-parser/pegex-json-pm/issues/3>.

=back

=item Other modules

Modules which are parts of bigger distributions have not been included
here except by accident.

=over

[% cpm('App::JSON::Tools') %]

Undocumented command-line tools for JSON.

[% cpm('App::JSONPretty') %]

👎🐛 JSON prettification script. For whatever reason the script
encapsulates the entirety of an old version of the L</JSON> module
dating from before L</JSON::PP> was included in the Perl core.

If you need this kind of script, there is something called L<json_xs>
which comes with L</JSON::XS>, or equivalently L<cpanel_json_xs> in
the forked module L</Cpanel::JSON::XS>.

[% cpm('ARGV::JSON') %]

[% cpm('JS::JSON') %]

👎 This is JavaScript code which was uploaded to CPAN. The original
JavaScript is now obsolete since the thing it codes is included in all
modern web browsers.

[% cpm('JSON::Eval') %]

Eval Perl code found in JSON. This module enables one to encode and
decode Perl scalar references and code references to JSON.

[% cpm('JSON::ize') %]

Something about one-liners.

[% cpm('JSON::JSend') %]

[% cpm('JSON::Lines') %]

"JSON Lines is a convenient format for storing structured data that
may be processed one record at a time."

[% cpm('JSON::Meth') %]

😕 Claims to be "no nonsense JSON encoding/decoding as method calls on
data". From the documentation:

=over

Don't make me think and give me what I want! This module automatically
figures out whether you want to encode a Perl data structure to JSON
or decode a JSON string to a Perl data structure.

=back

[% cpm('JSON::ON') %]

JavaScript object notation object notator.

[% cpm('JSON::SL') %]

😕

[% cpm('JSON::Streaming::Reader') %]

[% cpm('JSON::Streaming::Writer') %]

[% cpm('JSON::Util') %]

Relies on L<JSON::MaybeXS> and the author's other module L<IO::Any>,
so that you can put either a file name or a JSON string as the
argument and it tries to work out which one you have given it. That is
ingenious, but it seems that if you are a programmer who cannot
distinguish whether your input string is a file name or JSON, you have
a very serious problem.

[% cpm('JSON::XS::ByteString') %]

😕 L<The
README|https://metacpan.org/source/CINDY/JSON-XS-ByteString-1.004/README>
claims it is a "thin wrapper around JSON::XS", but L<it contains a
complete implementation of
JSON|https://metacpan.org/source/CINDY/JSON-XS-ByteString-1.004/ByteString.xs>,
which seems to have partly been copy-pasted from the JSON::XS source
code, but internally it doesn't make any reference to JSON::XS. The
licence and copyright statement don't mention JSON::XS's original
author at all so we're not sure if this is a fork, a wrapper, or a
reimplementation.

We haven't tried downloading this or installing it, but according to
the documentation, this module encodes numbers with quotes around
them, so C<< {this => 2} >> turns into C<{"this":"2"}>.

[% cpm('Text::JSON::Nibble') %]

Nibble complete JSON objects from buffers.

This seems to be for extracting JSON from the midst of noise.

=back

=back

=head1 SCRIPT

A script "validjson" is supplied with the module. This runs
L</assert_valid_json> on its inputs, so run it like this.

     validjson *.json

The default behaviour is to just do nothing if the input is valid. For
invalid input it prints what the problem is:

    validjson ids.go 
    ids.go: JSON error at line 1, byte 1/7588: Unexpected character '/' parsing initial state: expecting whitespace: '\n', '\r', '\t', ' ' or start of string: '"' or digit: '0-9' or minus: '-' or start of an array or object: '{', '[' or start of literal: 't', 'f', 'n'.

If you need confirmation, use its --verbose option:

    validjson -v *.json

    atoms.json is valid JSON.
    ids.json is valid JSON.
    kanjidic.json is valid JSON.
    linedecomps.json is valid JSON.
    radkfile-radicals.json is valid JSON.

=head1 DEPENDENCIES

=over

=item L<Carp>

=back

=head1 EXPORTS

The module exports nothing by default. Functions L</parse_json>,
L</parse_json_safe>, L</read_json>, L</valid_json> and
L</assert_valid_json>, as well as the old function names
L</validate_json>, L</json_file_to_perl>, and L</json_to_perl>, can be
exported on request.

All of the functions can be exported using the tag ':all':

    use JSON::Parse ':all';

=head1 TESTING

=head2 Internal testing code

The module incorporates extensive testing related to the production of
error messages and validation of input. Some of the testing code is
supplied with the module in the F</t/> subdirectory of the
distribution.

More extensive testing code is in the git repository. This is not
supplied in the CPAN distribution. A script, [% repo("randomjson.pl") %],
generates a set number of bytes of random JSON and checks that the
module's bytewise validation of input is correct. It does this by
taking a valid fragment, then adding each possible byte from 0 to 255
to see whether the module correctly identifies it as valid or invalid
at that point, then randomly picking one of the valid bytes and adding
it to the fragment and continuing the process until a complete valid
JSON input is formed. The module has undergone about a billion
repetitions of this test.

This setup relies on a C file, [% repo("json-random-test.c") %], which
isn't in the CPAN distribution, and it also requires [%
repo("Json3.xs") %] to be edited to make the macro C<TESTRANDOM> true
(uncomment line 7 of the file). The testing code uses C
setjmp/longjmp, so it's not guaranteed to work on all operating
systems and is commented out for CPAN releases.

A pure C version called [% repo("random-test.c") %] also exists. This applies
exactly the same tests, and requires no Perl at all.

If you're interested in testing your own JSON parser, the outputs
generated by [% repo("randomjson.pl") %] are quite a good place to
start. The default is to produce UTF-8 output, which looks pretty
horrible since it tends to produce long strings of UTF-8
garbage. (This is because it chooses randomly from 256 bytes and the
end-of-string marker C<"> has only a 1/256 chance of being chosen, so
the strings tend to get long and messy). You can mess with the
internals of JSON::Parse by setting MAXBYTE in F<json-common.c> to
0x80, recompiling (you can ignore the compiler warnings), and running
F<randomjson.pl> again to get just ASCII random JSON things. This
breaks the UTF-8 functionality of JSON::Parse, so please don't install
that version.

=head2 JSON Parsing Test Suite

JSON::Parse version 0.58 passes most of the JSON Parsing Test Suite,
with the exception that JSON::Parse rejects various erroneous UTF-8
inputs, for example JSON::Parse will throw an error for non-character
code points like Unicode U+FFFF and U+10FFFF. This parser only accepts
valid UTF-8 as input. See L</UTF-8 only>. 

In our opinion it would be a disservice to users of this module to
allow bytes containing useless fragments such as incomplete parts of
surrogate pairs, or invalid characters, just because the JSON
specification doesn't actually explicitly demand rejecting these kinds
of garbage inputs. Please see the function C<daft_test> in the file
F<xt/JPXT.pm> for exactly which of these elements of the test suite we
do not comply with. We note that this comment from Douglas Crockford,
the inventor of JSON, L<JSON
parser|https://github.com/douglascrockford/JSON-c/blob/master/utf8_decode.c#L38-L43>,
dated 2005, agrees with our opinion on this point.

JSON::Parse version 0.58 also introduced L</get_max_depth> and
L</set_max_depth> to prevent the stack overflow errors caused by some
very deeply nested inputs such as those of the JSON Parsing Test
Suite.

=head2 Test results

=over

=item L<ActiveState PPM|http://code.activestate.com/ppm/JSON-Parse/>.

=item L<CPAN testers|http://matrix.cpantesters.org/?dist=JSON-Parse+[% version %]>

=item L<Travis CI|https://travis-ci.com/github/benkasminbullock/JSON-Parse>

=back

=head1 ACKNOWLEDGEMENTS

Toby Inkster (TOBYINK) suggested some of the new function names which
replaced the L</OLD INTERFACE> names. Nicolas Immelman and Shlomi Fish
(SHLOMIF) reported memory leaks which were fixed in 0.32 and
0.40. Github user kolmogorov42 reported a bug which led to
0.42. Github user SteveGlassman found an error in string copying for
long strings, fixed in 0.57. Lars Dɪᴇᴄᴋᴏᴡ (DAXIM) pointed out problems
with the JSON Parsing Test Suite which led to the addition of stack
protection and L</set_max_depth> and L</get_max_depth> in 0.58.

[% start_year=2013 %]
[% INCLUDE "author" %]
